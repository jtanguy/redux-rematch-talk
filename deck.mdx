import { Head, Appear, Image, Notes } from 'mdx-deck'
export { components } from "mdx-deck-code-surfer"
export { default as theme } from './theme'
import Simple from './samples/simple.js'

<Head>
  <title>Redux + Rematch</title>
  <meta name="author" title="Julien Tanguy"/>
  <meta name='twitter:site' content='@jutanguy' />
</Head>

# Redux + Rematch

Comment gérer un état qui n'en finit pas de grossir

---

# Application

<ul style={{textAlign: 'left'}}>
<li> Profil utilisateur </li>
<li> Messages </li>
<li> Objets métier </li>
<Appear>
<li> Préférences </li>
<li> Chat </li>
<li> Nouveaux objets métier </li>
<li> Fusion de plusieurs objets </li>
</Appear>
</ul>

<Notes>

Prenons une application classique.

Elle grandit et grandit et grandit

</Notes>

---

![](images/redux-light.png)

---

<Image src="https://staltz.com/img/redux-unidir-ui-arch.jpg" size="contain"/>

---

# Concepts

---

## Actions

* `{type: 'COMMENT_ADDED', id: 'M927q6hd5', content: 'First!'}`
* `{type: 'COMMENT_ADDED', id: 'eqVFsAUsEC', content: 'First!'}`
* `{type: 'COMMENT_EDITED', id: 'eqVFsAUsEC', content: 'Second, actually'}`
* `{type: 'COMMENT_REMOVED', id: 'eqVFsAUsEC'}`


<Notes>

Les actions sont les éléments de base de redux

Ce sont des objets avec une clé `type`
</Notes>

---

```js Reducers
const initialState = []

export default function reducer(state = initialState, action){
  switch(action.type){
    case 'COMMENT_ADDED':
      return [...state, {id: action.id, content: action.content}]
    case 'COMMENT_EDITED':
      return state.map(comment => {
        if(comment.id === action.id){
          return ({id: comment.id, content: action.content})
        } else {
          return comment
        }
      })
    case 'COMMENT_REMOVED':
      return state.filter(comment => comment.id !== action.id)
    default:
      return state
  }
}
```

<Notes>
Reducers, ou reducer functions
</Notes>

---

## Store


---


<Simple/>


---

# Redux === Code applicatif

---

Utilisation avec React

* Connect
* container vs components

---

> “You might not need Redux”

– Dan Abramov

---

```jsx Use the Context, Luke
import React from 'react'

const ThemeContext = React.createContext('dark')

class App extends React.Component {
  render() {
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

class ThemedButton extends React.Component {
  static contextType = ThemeContext;
  render() {
    return <Button theme={this.context} />;
  }
}
----
*
3 > API context
5:13
8,10 > Context.Provider
15:21
18 > Pas de theme ici
23:28
24,26 > contextType (React 16.6)
*
```

---

## asynchrone

* redux thunk

* je ne parlerai pas des sagas


---
Instant protip

* redux-api-middleware non, et pourquoi (mélange de commandes et d'events, middleware)

* redux-form non, et pourquoi

--- 

Overdose de verbosité

* trop d'action creators
* et de
* code
* dans pleins de fichiers

--- 

Instant protip

containers vs components => screens et components/ui

---

## redux ducks

https://github.com/erikras/ducks-modular-redux


---

## Tests

jest

--- 

## rematch

https://hackernoon.com/redesigning-redux-b2baee8b8a38

rematch = ducks + thunk 


---

## eventsourcing

* Bien insister sur le concept d'évènement, de fait passé
* parallèle effect/command

---

## Instant protiop

* revenir dans les devtools


---

## Exemple boite de commentaire

mini formulaire: add + edit

* import/export

Historique ?

BOOM! même import



---
# Liens

* <https://redux.js.org>
* Rematch
